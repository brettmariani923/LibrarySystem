How it works:

1. The client sends a json request

    POST /api/books
    Content-Type: application/json

    {
      "title": "The Hobbit",
      "author": "J.R.R. Tolkien",
      "genre": "Fantasy",
      "publishedYear": 1937
    }


2. Controller recieves the request

 [HttpPost]
    public async Task<IActionResult> Create([FromBody] BookDTO? DTO)
    {
        if (DTO == null)
            return BadRequest("Book data must not be null.");

        var created = await _service.CreateAsync(DTO);
        return CreatedAtAction(nameof(GetById), new { id = created.Id }, created);
    }

        -ASP.NET Core automatically deserializes the JSON into a BookDTO object.


3. IBookService Interface is called from the controller method. The controller passes it to _service.CreateAsync(DTO) method.


4. BookService Handles the Logic

    public async Task<BookDTO> CreateAsync(BookDTO DTO)
    {
        if (DTO == null)
            throw new ArgumentNullException(nameof(DTO), "Book DTO cannot be null");

        var book = new Book
        {
            Title = DTO.Title,
            Author = DTO.Author,
            Genre = DTO.Genre,
            PublishedYear = DTO.PublishedYear
        };

        _context.Books.Add(book);
        await _context.SaveChangesAsync();

        DTO.Id = book.Id;
        return DTO;
    }

    -A Book entity is created from the DTO.
    -Its added to the LibraryDbContext
    -EF Core saves it to the database.
    -The generated Id is assigned back to the DTO, which is returned


5. LibraryDbContext writes to SQLite (or In-Memory)

    -DbContext maps the Book entity to a SQL table
    -uses Fluent API to define constraints
    -writes to library.db


6. Controller Returns Response

    return CreatedAtAction(nameof(GetById), new { id = created.Id }, created);

    -returns HTTP 201 Created
    -JSON representation of the new book
    -Location header pointing to /api/books/{id}


//for dbcontext to be able to do any work, it needs an instance of the DbContextOptions class, which contains configuration info like the database provider and connection string.
// To handle this we are going to use dependency injection elsewhere in the application to provide the DbContextOptions when the LibraryDbContext is created.
//because we want our dbcontextoptionos to work with our librarydbcontext, we use DbContextOptions<LibraryDbContext> as the type for the options parameter in the constructor,
// This way, when the DI container creates an instance of LibraryDbContext, it knows to provide the correct options specifically configured for it.

//options serves as the name of the parameter that will hold the configuration settings needed by the DbContext.
//because we want to pass those options to the base DbContext class, we call the base constructor with : base(options)

//By doing this, we ensure that the LibraryDbContext is properly configured with the necessary settings to connect to the database and perform its operations.